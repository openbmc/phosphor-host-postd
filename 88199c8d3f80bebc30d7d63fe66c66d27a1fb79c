{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6b44bf01_418aefcf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 9,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2023-04-26T22:09:12Z",
      "side": 1,
      "message": "Need to reword this. 65k/sec was measured as the maximum rate that snoopd can dequeue bytes from the kernel, if the D-Bus property updates are commented out. The rate that the host CPU writes is unknown, but possibly much greater.",
      "range": {
        "startLine": 9,
        "startChar": 52,
        "endLine": 9,
        "endChar": 66
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11d1af72_4325dad7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 37,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2023-04-27T23:46:39Z",
      "side": 1,
      "message": "If CPU is writing faster than 1k code/sec and more than 2K, this driver buffer will be overrun and post code gets lost, right?\nBut that is not the normal case.",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 37,
        "endChar": 50
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c5116fc_ca669a3d",
        "filename": "main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 122,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2023-04-26T21:04:55Z",
      "side": 1,
      "message": "both of these should be configuration. and have options to turn it off if needed.",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 122,
        "endChar": 0
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b40e10c7_7496e851",
        "filename": "main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 122,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2023-04-26T22:09:12Z",
      "side": 1,
      "message": "Agreed, will add.",
      "parentUuid": "6c5116fc_ca669a3d",
      "range": {
        "startLine": 120,
        "startChar": 0,
        "endLine": 122,
        "endChar": 0
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62aba380_79980d9b",
        "filename": "main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-04-26T21:00:36Z",
      "side": 1,
      "message": "Might it be good to at least log a message like \"Warning: dropped N POST codes\" or something if the rate limit is actually exceeded, just so it doesn\u0027t happen totally silently?  Though I suppose there\u0027s then the problem of flooding the log if the overload is sustained instead of just a brief burst, which might then necessitate its own log rate-limiting or coalescing of some sort...thoughts?",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 149,
        "endChar": 31
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3229937c_bfae1517",
        "filename": "main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2023-04-26T22:09:12Z",
      "side": 1,
      "message": "We\u0027re not necessarily dropping anything here. We\u0027re just taking a little break :) - something that might happen anyway due to other processes getting scheduled. Once the sleep is over, it\u0027ll pick up right where it left off. IMO hitting the rate limit doesn\u0027t mean that anything has gone wrong or needs to be logged.\n\nOn the other hand, the aspeed-lpc-snoop kernel driver will drop bytes if userspace doesn\u0027t read them in time - so that\u0027s where something could be logged if we wanted to be notified of it. But I also don\u0027t think there\u0027s any guarantee that the driver will see every incoming byte. The HW only saves the last two snooped bytes and if the IRQ isn\u0027t handled before more bytes are written then there will be silent data loss. So it\u0027s an inherently non-coherent or unreliable channel.",
      "parentUuid": "62aba380_79980d9b",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 149,
        "endChar": 31
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b86de62_99ae6f9f",
        "filename": "main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-04-26T23:29:20Z",
      "side": 1,
      "message": "Ah right, that makes sense.  Just to get a rough sense of relative scales, do you know roughly how many unprocessed POST codes it takes for things to become problematic in the two cases described in the commit message?  For reference, on the kernel side it looks like the snoop driver uses a 2048-entry fifo, FWIW: https://github.com/openbmc/linux/blob/288cdbcca137444c131180738a8046c93ae228f0/drivers/soc/aspeed/aspeed-lpc-snoop.c#L30",
      "parentUuid": "3229937c_bfae1517",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 149,
        "endChar": 31
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b651f895_00247a8d",
        "filename": "main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2023-04-27T20:50:31Z",
      "side": 1,
      "message": "I just tested the two cases by modifying snoopd and post-code-manager to print out the number of codes processed every 100 codes and checked the difference when the BMC grinds to a halt.\n\nCase 2 is the more common failure in my system. I forced Case 1 by calling bus.flush() for each code to force the message into dbus-broker.\n\nCase 1: 201200 signals stuck in dbus-broker (snoopd processed 764000, post-code-manager 562800)\nCase 2: 160300 signals stuck in snoopd (snoopd processed 307500, post-code-manager 147000)\n\nThis number will obviously depend on the POST code size and free system memory. Our Intel systems just use a single byte POST code. Both cases take less than 5 minutes to kill the BMC FW, with Case 2 being faster (sometimes less than 1 minute).",
      "parentUuid": "2b86de62_99ae6f9f",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 149,
        "endChar": 31
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd7ec4b3_2c60475e",
        "filename": "main.cpp",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-04-27T22:38:07Z",
      "side": 1,
      "message": "Alright, thanks for the extra info...sounds good.",
      "parentUuid": "b651f895_00247a8d",
      "range": {
        "startLine": 146,
        "startChar": 0,
        "endLine": 149,
        "endChar": 31
      },
      "revId": "88199c8d3f80bebc30d7d63fe66c66d27a1fb79c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}